
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:cloud_functions/cloud_functions.dart';
import '../domain/chat_model.dart';

class ChatRepository {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseFunctions _functions = FirebaseFunctions.instance;

  // Fetch real-time messages for a thread
  Stream<List<ChatMessage>> getMessages(String threadId) {
    return _firestore
        .collection('chat_threads')
        .doc(threadId)
        .collection('messages')
        .orderBy('sentAt', descending: true)
        .snapshots()
        .map((snapshot) {
      return snapshot.docs.map((doc) => ChatMessage.fromFirestore(doc)).toList();
    });
  }

  // Send a message
  Future<void> sendMessage(String threadId, String senderId, String content) async {
    final message = ChatMessage(
      id: '', // Generated by Firestore
      senderId: senderId,
      content: content,
      sentAt: DateTime.now(),
    );

    await _firestore
        .collection('chat_threads')
        .doc(threadId)
        .collection('messages')
        .add(message.toMap());

    // Update thread summary
    await _firestore.collection('chat_threads').doc(threadId).update({
      'lastMessage': content,
      'lastMessageTime': FieldValue.serverTimestamp(),
    });
  }

  // Call Genkit function for Match Report
  Future<String> getMatchReport({
    required String userAName,
    required String userBName,
    required List<String> sharedValues,
    required List<String> frictionPoints,
  }) async {
    try {
      final result = await _functions.httpsCallable('generateMatchReport').call({
        'userAName': userAName,
        'userBName': userBName,
        'sharedValues': sharedValues,
        'frictionPoints': frictionPoints,
      });
      return result.data as String;
    } catch (e) {
      print('Error generating report: $e');
      return 'Unable to generate report at this time.';
    }
  }

  // Call Genkit function for Ice Breakers
  Future<List<String>> getIceBreakers(List<String> sharedValues) async {
    try {
      final result = await _functions.httpsCallable('suggestIceBreakers').call({
        'sharedValues': sharedValues,
      });
      return List<String>.from(result.data);
    } catch (e) {
      print('Error fetching ice breakers: $e');
      return [];
    }
  }
}

